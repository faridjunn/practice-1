# Понимание рекурсии с помощью JavaScript
## Что такое рекурсия?
Рекурсивно определенная функция - это функция, которая определяется в терминах более простой версии самой себя. Это упрощенный пример:
######  функция doA(n) {
 если (n > 0) {
 doA(n-1);
    }
}
- Чтобы понять, как рекурсия работает концептуально, мы рассмотрим пример, который не имеет ничего общего с кодом. Представьте, что вы отвечаете за ответы на телефонные звонки на работе. Поскольку это загруженная компания, на вашем телефоне несколько телефонных линий, поэтому вы можете переключать несколько вызовов одновременно. На каждой телефонной линии есть кнопка на приемнике, и при поступлении входящего вызова кнопка будет мигать. Сегодня, когда вы приходите на работу и включаете телефон, мигают сразу четыре строки. Итак, вы приступаете к работе, отвечая на все вызовы.

- Вы открываете первую строку и говорите им: "Пожалуйста, подождите". Затем вы открываете вторую строку и переводите их в режим ожидания. Затем вы переходите к третьей строке и переводите их в режим ожидания, и так далее. Наконец, когда вы закончите с каждым вызовом, вы возвращаетесь к предыдущему вызывающему, завершаете этот вызов и вешаете трубку.

- Каждый из телефонных вызовов в этом примере подобен рекурсивному вызову в функции. Когда вы получаете вызов, он помещается в стек вызовов (в code speak). Если вы не можете завершить вызов сразу, вы переводите вызов в режим ожидания. Если у вас есть вызов функции, который не может быть оценен немедленно, он остается в стеке вызовов. Когда вы в состоянии ответить на вызов, он принимается. Когда ваш код способен оценить вызов функции, он извлекается из стека. Помните об этой аналогии при просмотре следующих примеров кода.

 ## Рекурсия с числами
- Все рекурсивные функции нуждаются в базовом варианте, чтобы они завершались. Однако простое добавление базового варианта к нашей функции не мешает ей выполняться бесконечно. Функция должна иметь шаг, чтобы приблизить нас к базовому варианту. Это рекурсивный шаг. На рекурсивном шаге проблема сводится к уменьшенной версии проблемы.

- Suppose you have a function that will multiply all the numbers from 1 to n. This is called the factorial function, and we write it as n!. For example, 4!, is 1 * 2 * 3 * 4 = 24.
-  First, we determine the base case. Finding the base case can also be thought of as finding the case where the problem can be solved without recursion. In this case, it is when n equals one.  

- At each step, you will subtract one from the current number. What is the recursive case? The recursive case is the function fact called with the reduced number.
###### function fact(num) {
    if (num === 1) 
		return 1;
	else 
		return num * fact(--num);
}
fact(4); //24

# Замыкание
**JavaScript** – язык с сильным функционально-ориентированным уклоном. Он даёт нам много свободы. Функция может быть динамически создана, скопирована в другую переменную или передана как аргумент другой функции и позже вызвана из совершенно другого места.

-Мы знаем, что функция может получить доступ к переменным из внешнего окружения, эта возможность используется очень часто.

-Но что произойдёт, когда внешние переменные изменятся? Функция получит последнее значение или то, которое существовало на момент создания функции?

-И что произойдёт, когда функция переместится в другое место в коде и будет вызвана оттуда – получит ли она доступ к внешним переменным своего нового местоположения?

-Разные языки ведут себя по-разному в таких случаях, и в этой главе мы рассмотрим поведение *JavaScript*.

### Пара вопросов 
Для начала давайте рассмотрим две ситуации, а затем изучим внутренние механизмы шаг за шагом, чтобы вы смогли ответить на эти и более сложные вопросы в будущем.

1.Функция _sayHi_ использует внешнюю переменную name. Какое значение будет использовать функция при выполнении?
###### let name = "John";
function sayHi() {
  alert("Hi, " + name);
}
name = "Pete";

sayHi(); // что будет показано: "John" или "Pete"?

Такие ситуации распространены и в браузерной и в серверной разработке. Выполнение функции может быть запланировано позже, чем она была создана, например, после какого-нибудь пользовательского действия или сетевого запроса.

Итак, вопрос в том, получит ли она доступ к последним изменениям?

2.Функция makeWorker создаёт другую функцию и возвращает её. Новая функция может быть вызвана откуда-то ещё. Получит ли она доступ к внешним переменным из места своего создания или места выполнения или из обоих?

###### function makeWorker() {
  let name = "Pete";
 return function() {
    alert(name);
  };
}
let name = "John";

// create a function
let work = makeWorker();

// call it
work(); // что будет показано? "Pete" (из места создания) или "John" (из места выполнения)



